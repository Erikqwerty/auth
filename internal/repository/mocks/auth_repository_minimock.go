// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/erikqwerty/auth/internal/repository.AuthRepository -o auth_repository_minimock.go -n AuthRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/erikqwerty/auth/internal/model"
	"github.com/gojuno/minimock/v3"
)

// AuthRepositoryMock implements mm_repository.AuthRepository
type AuthRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateLog          func(ctx context.Context, log *model.Log) (err error)
	funcCreateLogOrigin    string
	inspectFuncCreateLog   func(ctx context.Context, log *model.Log)
	afterCreateLogCounter  uint64
	beforeCreateLogCounter uint64
	CreateLogMock          mAuthRepositoryMockCreateLog

	funcCreateUser          func(ctx context.Context, user *model.CreateUser) (i1 int64, err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, user *model.CreateUser)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mAuthRepositoryMockCreateUser

	funcDeleteUser          func(ctx context.Context, id int64) (err error)
	funcDeleteUserOrigin    string
	inspectFuncDeleteUser   func(ctx context.Context, id int64)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mAuthRepositoryMockDeleteUser

	funcReadUser          func(ctx context.Context, email string) (up1 *model.UserInfo, err error)
	funcReadUserOrigin    string
	inspectFuncReadUser   func(ctx context.Context, email string)
	afterReadUserCounter  uint64
	beforeReadUserCounter uint64
	ReadUserMock          mAuthRepositoryMockReadUser

	funcUpdateUser          func(ctx context.Context, user *model.UpdateUser) (err error)
	funcUpdateUserOrigin    string
	inspectFuncUpdateUser   func(ctx context.Context, user *model.UpdateUser)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mAuthRepositoryMockUpdateUser
}

// NewAuthRepositoryMock returns a mock for mm_repository.AuthRepository
func NewAuthRepositoryMock(t minimock.Tester) *AuthRepositoryMock {
	m := &AuthRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateLogMock = mAuthRepositoryMockCreateLog{mock: m}
	m.CreateLogMock.callArgs = []*AuthRepositoryMockCreateLogParams{}

	m.CreateUserMock = mAuthRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*AuthRepositoryMockCreateUserParams{}

	m.DeleteUserMock = mAuthRepositoryMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*AuthRepositoryMockDeleteUserParams{}

	m.ReadUserMock = mAuthRepositoryMockReadUser{mock: m}
	m.ReadUserMock.callArgs = []*AuthRepositoryMockReadUserParams{}

	m.UpdateUserMock = mAuthRepositoryMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*AuthRepositoryMockUpdateUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthRepositoryMockCreateLog struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockCreateLogExpectation
	expectations       []*AuthRepositoryMockCreateLogExpectation

	callArgs []*AuthRepositoryMockCreateLogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockCreateLogExpectation specifies expectation struct of the AuthRepository.CreateLog
type AuthRepositoryMockCreateLogExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockCreateLogParams
	paramPtrs          *AuthRepositoryMockCreateLogParamPtrs
	expectationOrigins AuthRepositoryMockCreateLogExpectationOrigins
	results            *AuthRepositoryMockCreateLogResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockCreateLogParams contains parameters of the AuthRepository.CreateLog
type AuthRepositoryMockCreateLogParams struct {
	ctx context.Context
	log *model.Log
}

// AuthRepositoryMockCreateLogParamPtrs contains pointers to parameters of the AuthRepository.CreateLog
type AuthRepositoryMockCreateLogParamPtrs struct {
	ctx *context.Context
	log **model.Log
}

// AuthRepositoryMockCreateLogResults contains results of the AuthRepository.CreateLog
type AuthRepositoryMockCreateLogResults struct {
	err error
}

// AuthRepositoryMockCreateLogOrigins contains origins of expectations of the AuthRepository.CreateLog
type AuthRepositoryMockCreateLogExpectationOrigins struct {
	origin    string
	originCtx string
	originLog string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateLog *mAuthRepositoryMockCreateLog) Optional() *mAuthRepositoryMockCreateLog {
	mmCreateLog.optional = true
	return mmCreateLog
}

// Expect sets up expected params for AuthRepository.CreateLog
func (mmCreateLog *mAuthRepositoryMockCreateLog) Expect(ctx context.Context, log *model.Log) *mAuthRepositoryMockCreateLog {
	if mmCreateLog.mock.funcCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("AuthRepositoryMock.CreateLog mock is already set by Set")
	}

	if mmCreateLog.defaultExpectation == nil {
		mmCreateLog.defaultExpectation = &AuthRepositoryMockCreateLogExpectation{}
	}

	if mmCreateLog.defaultExpectation.paramPtrs != nil {
		mmCreateLog.mock.t.Fatalf("AuthRepositoryMock.CreateLog mock is already set by ExpectParams functions")
	}

	mmCreateLog.defaultExpectation.params = &AuthRepositoryMockCreateLogParams{ctx, log}
	mmCreateLog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateLog.expectations {
		if minimock.Equal(e.params, mmCreateLog.defaultExpectation.params) {
			mmCreateLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateLog.defaultExpectation.params)
		}
	}

	return mmCreateLog
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.CreateLog
func (mmCreateLog *mAuthRepositoryMockCreateLog) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockCreateLog {
	if mmCreateLog.mock.funcCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("AuthRepositoryMock.CreateLog mock is already set by Set")
	}

	if mmCreateLog.defaultExpectation == nil {
		mmCreateLog.defaultExpectation = &AuthRepositoryMockCreateLogExpectation{}
	}

	if mmCreateLog.defaultExpectation.params != nil {
		mmCreateLog.mock.t.Fatalf("AuthRepositoryMock.CreateLog mock is already set by Expect")
	}

	if mmCreateLog.defaultExpectation.paramPtrs == nil {
		mmCreateLog.defaultExpectation.paramPtrs = &AuthRepositoryMockCreateLogParamPtrs{}
	}
	mmCreateLog.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateLog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateLog
}

// ExpectLogParam2 sets up expected param log for AuthRepository.CreateLog
func (mmCreateLog *mAuthRepositoryMockCreateLog) ExpectLogParam2(log *model.Log) *mAuthRepositoryMockCreateLog {
	if mmCreateLog.mock.funcCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("AuthRepositoryMock.CreateLog mock is already set by Set")
	}

	if mmCreateLog.defaultExpectation == nil {
		mmCreateLog.defaultExpectation = &AuthRepositoryMockCreateLogExpectation{}
	}

	if mmCreateLog.defaultExpectation.params != nil {
		mmCreateLog.mock.t.Fatalf("AuthRepositoryMock.CreateLog mock is already set by Expect")
	}

	if mmCreateLog.defaultExpectation.paramPtrs == nil {
		mmCreateLog.defaultExpectation.paramPtrs = &AuthRepositoryMockCreateLogParamPtrs{}
	}
	mmCreateLog.defaultExpectation.paramPtrs.log = &log
	mmCreateLog.defaultExpectation.expectationOrigins.originLog = minimock.CallerInfo(1)

	return mmCreateLog
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.CreateLog
func (mmCreateLog *mAuthRepositoryMockCreateLog) Inspect(f func(ctx context.Context, log *model.Log)) *mAuthRepositoryMockCreateLog {
	if mmCreateLog.mock.inspectFuncCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.CreateLog")
	}

	mmCreateLog.mock.inspectFuncCreateLog = f

	return mmCreateLog
}

// Return sets up results that will be returned by AuthRepository.CreateLog
func (mmCreateLog *mAuthRepositoryMockCreateLog) Return(err error) *AuthRepositoryMock {
	if mmCreateLog.mock.funcCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("AuthRepositoryMock.CreateLog mock is already set by Set")
	}

	if mmCreateLog.defaultExpectation == nil {
		mmCreateLog.defaultExpectation = &AuthRepositoryMockCreateLogExpectation{mock: mmCreateLog.mock}
	}
	mmCreateLog.defaultExpectation.results = &AuthRepositoryMockCreateLogResults{err}
	mmCreateLog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateLog.mock
}

// Set uses given function f to mock the AuthRepository.CreateLog method
func (mmCreateLog *mAuthRepositoryMockCreateLog) Set(f func(ctx context.Context, log *model.Log) (err error)) *AuthRepositoryMock {
	if mmCreateLog.defaultExpectation != nil {
		mmCreateLog.mock.t.Fatalf("Default expectation is already set for the AuthRepository.CreateLog method")
	}

	if len(mmCreateLog.expectations) > 0 {
		mmCreateLog.mock.t.Fatalf("Some expectations are already set for the AuthRepository.CreateLog method")
	}

	mmCreateLog.mock.funcCreateLog = f
	mmCreateLog.mock.funcCreateLogOrigin = minimock.CallerInfo(1)
	return mmCreateLog.mock
}

// When sets expectation for the AuthRepository.CreateLog which will trigger the result defined by the following
// Then helper
func (mmCreateLog *mAuthRepositoryMockCreateLog) When(ctx context.Context, log *model.Log) *AuthRepositoryMockCreateLogExpectation {
	if mmCreateLog.mock.funcCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("AuthRepositoryMock.CreateLog mock is already set by Set")
	}

	expectation := &AuthRepositoryMockCreateLogExpectation{
		mock:               mmCreateLog.mock,
		params:             &AuthRepositoryMockCreateLogParams{ctx, log},
		expectationOrigins: AuthRepositoryMockCreateLogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateLog.expectations = append(mmCreateLog.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.CreateLog return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockCreateLogExpectation) Then(err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockCreateLogResults{err}
	return e.mock
}

// Times sets number of times AuthRepository.CreateLog should be invoked
func (mmCreateLog *mAuthRepositoryMockCreateLog) Times(n uint64) *mAuthRepositoryMockCreateLog {
	if n == 0 {
		mmCreateLog.mock.t.Fatalf("Times of AuthRepositoryMock.CreateLog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateLog.expectedInvocations, n)
	mmCreateLog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateLog
}

func (mmCreateLog *mAuthRepositoryMockCreateLog) invocationsDone() bool {
	if len(mmCreateLog.expectations) == 0 && mmCreateLog.defaultExpectation == nil && mmCreateLog.mock.funcCreateLog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateLog.mock.afterCreateLogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateLog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateLog implements mm_repository.AuthRepository
func (mmCreateLog *AuthRepositoryMock) CreateLog(ctx context.Context, log *model.Log) (err error) {
	mm_atomic.AddUint64(&mmCreateLog.beforeCreateLogCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateLog.afterCreateLogCounter, 1)

	mmCreateLog.t.Helper()

	if mmCreateLog.inspectFuncCreateLog != nil {
		mmCreateLog.inspectFuncCreateLog(ctx, log)
	}

	mm_params := AuthRepositoryMockCreateLogParams{ctx, log}

	// Record call args
	mmCreateLog.CreateLogMock.mutex.Lock()
	mmCreateLog.CreateLogMock.callArgs = append(mmCreateLog.CreateLogMock.callArgs, &mm_params)
	mmCreateLog.CreateLogMock.mutex.Unlock()

	for _, e := range mmCreateLog.CreateLogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateLog.CreateLogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateLog.CreateLogMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateLog.CreateLogMock.defaultExpectation.params
		mm_want_ptrs := mmCreateLog.CreateLogMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockCreateLogParams{ctx, log}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateLog.t.Errorf("AuthRepositoryMock.CreateLog got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateLog.CreateLogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.log != nil && !minimock.Equal(*mm_want_ptrs.log, mm_got.log) {
				mmCreateLog.t.Errorf("AuthRepositoryMock.CreateLog got unexpected parameter log, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateLog.CreateLogMock.defaultExpectation.expectationOrigins.originLog, *mm_want_ptrs.log, mm_got.log, minimock.Diff(*mm_want_ptrs.log, mm_got.log))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateLog.t.Errorf("AuthRepositoryMock.CreateLog got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateLog.CreateLogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateLog.CreateLogMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateLog.t.Fatal("No results are set for the AuthRepositoryMock.CreateLog")
		}
		return (*mm_results).err
	}
	if mmCreateLog.funcCreateLog != nil {
		return mmCreateLog.funcCreateLog(ctx, log)
	}
	mmCreateLog.t.Fatalf("Unexpected call to AuthRepositoryMock.CreateLog. %v %v", ctx, log)
	return
}

// CreateLogAfterCounter returns a count of finished AuthRepositoryMock.CreateLog invocations
func (mmCreateLog *AuthRepositoryMock) CreateLogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateLog.afterCreateLogCounter)
}

// CreateLogBeforeCounter returns a count of AuthRepositoryMock.CreateLog invocations
func (mmCreateLog *AuthRepositoryMock) CreateLogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateLog.beforeCreateLogCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.CreateLog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateLog *mAuthRepositoryMockCreateLog) Calls() []*AuthRepositoryMockCreateLogParams {
	mmCreateLog.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockCreateLogParams, len(mmCreateLog.callArgs))
	copy(argCopy, mmCreateLog.callArgs)

	mmCreateLog.mutex.RUnlock()

	return argCopy
}

// MinimockCreateLogDone returns true if the count of the CreateLog invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockCreateLogDone() bool {
	if m.CreateLogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateLogMock.invocationsDone()
}

// MinimockCreateLogInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockCreateLogInspect() {
	for _, e := range m.CreateLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateLog at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateLogCounter := mm_atomic.LoadUint64(&m.afterCreateLogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateLogMock.defaultExpectation != nil && afterCreateLogCounter < 1 {
		if m.CreateLogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateLog at\n%s", m.CreateLogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateLog at\n%s with params: %#v", m.CreateLogMock.defaultExpectation.expectationOrigins.origin, *m.CreateLogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateLog != nil && afterCreateLogCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.CreateLog at\n%s", m.funcCreateLogOrigin)
	}

	if !m.CreateLogMock.invocationsDone() && afterCreateLogCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.CreateLog at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateLogMock.expectedInvocations), m.CreateLogMock.expectedInvocationsOrigin, afterCreateLogCounter)
	}
}

type mAuthRepositoryMockCreateUser struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockCreateUserExpectation
	expectations       []*AuthRepositoryMockCreateUserExpectation

	callArgs []*AuthRepositoryMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockCreateUserExpectation specifies expectation struct of the AuthRepository.CreateUser
type AuthRepositoryMockCreateUserExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockCreateUserParams
	paramPtrs          *AuthRepositoryMockCreateUserParamPtrs
	expectationOrigins AuthRepositoryMockCreateUserExpectationOrigins
	results            *AuthRepositoryMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockCreateUserParams contains parameters of the AuthRepository.CreateUser
type AuthRepositoryMockCreateUserParams struct {
	ctx  context.Context
	user *model.CreateUser
}

// AuthRepositoryMockCreateUserParamPtrs contains pointers to parameters of the AuthRepository.CreateUser
type AuthRepositoryMockCreateUserParamPtrs struct {
	ctx  *context.Context
	user **model.CreateUser
}

// AuthRepositoryMockCreateUserResults contains results of the AuthRepository.CreateUser
type AuthRepositoryMockCreateUserResults struct {
	i1  int64
	err error
}

// AuthRepositoryMockCreateUserOrigins contains origins of expectations of the AuthRepository.CreateUser
type AuthRepositoryMockCreateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mAuthRepositoryMockCreateUser) Optional() *mAuthRepositoryMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) Expect(ctx context.Context, user *model.CreateUser) *mAuthRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &AuthRepositoryMockCreateUserParams{ctx, user}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &AuthRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectUserParam2 sets up expected param user for AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) ExpectUserParam2(user *model.CreateUser) *mAuthRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &AuthRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.user = &user
	mmCreateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) Inspect(f func(ctx context.Context, user *model.CreateUser)) *mAuthRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) Return(i1 int64, err error) *AuthRepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthRepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &AuthRepositoryMockCreateUserResults{i1, err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the AuthRepository.CreateUser method
func (mmCreateUser *mAuthRepositoryMockCreateUser) Set(f func(ctx context.Context, user *model.CreateUser) (i1 int64, err error)) *AuthRepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the AuthRepository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the AuthRepository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the AuthRepository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mAuthRepositoryMockCreateUser) When(ctx context.Context, user *model.CreateUser) *AuthRepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &AuthRepositoryMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &AuthRepositoryMockCreateUserParams{ctx, user},
		expectationOrigins: AuthRepositoryMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.CreateUser return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockCreateUserExpectation) Then(i1 int64, err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockCreateUserResults{i1, err}
	return e.mock
}

// Times sets number of times AuthRepository.CreateUser should be invoked
func (mmCreateUser *mAuthRepositoryMockCreateUser) Times(n uint64) *mAuthRepositoryMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of AuthRepositoryMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mAuthRepositoryMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_repository.AuthRepository
func (mmCreateUser *AuthRepositoryMock) CreateUser(ctx context.Context, user *model.CreateUser) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, user)
	}

	mm_params := AuthRepositoryMockCreateUserParams{ctx, user}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockCreateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("AuthRepositoryMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreateUser.t.Errorf("AuthRepositoryMock.CreateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("AuthRepositoryMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the AuthRepositoryMock.CreateUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, user)
	}
	mmCreateUser.t.Fatalf("Unexpected call to AuthRepositoryMock.CreateUser. %v %v", ctx, user)
	return
}

// CreateUserAfterCounter returns a count of finished AuthRepositoryMock.CreateUser invocations
func (mmCreateUser *AuthRepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of AuthRepositoryMock.CreateUser invocations
func (mmCreateUser *AuthRepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mAuthRepositoryMockCreateUser) Calls() []*AuthRepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mAuthRepositoryMockDeleteUser struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockDeleteUserExpectation
	expectations       []*AuthRepositoryMockDeleteUserExpectation

	callArgs []*AuthRepositoryMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockDeleteUserExpectation specifies expectation struct of the AuthRepository.DeleteUser
type AuthRepositoryMockDeleteUserExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockDeleteUserParams
	paramPtrs          *AuthRepositoryMockDeleteUserParamPtrs
	expectationOrigins AuthRepositoryMockDeleteUserExpectationOrigins
	results            *AuthRepositoryMockDeleteUserResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockDeleteUserParams contains parameters of the AuthRepository.DeleteUser
type AuthRepositoryMockDeleteUserParams struct {
	ctx context.Context
	id  int64
}

// AuthRepositoryMockDeleteUserParamPtrs contains pointers to parameters of the AuthRepository.DeleteUser
type AuthRepositoryMockDeleteUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// AuthRepositoryMockDeleteUserResults contains results of the AuthRepository.DeleteUser
type AuthRepositoryMockDeleteUserResults struct {
	err error
}

// AuthRepositoryMockDeleteUserOrigins contains origins of expectations of the AuthRepository.DeleteUser
type AuthRepositoryMockDeleteUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) Optional() *mAuthRepositoryMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for AuthRepository.DeleteUser
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) Expect(ctx context.Context, id int64) *mAuthRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("AuthRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &AuthRepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("AuthRepositoryMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &AuthRepositoryMockDeleteUserParams{ctx, id}
	mmDeleteUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.DeleteUser
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("AuthRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &AuthRepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("AuthRepositoryMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &AuthRepositoryMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUser
}

// ExpectIdParam2 sets up expected param id for AuthRepository.DeleteUser
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) ExpectIdParam2(id int64) *mAuthRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("AuthRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &AuthRepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("AuthRepositoryMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &AuthRepositoryMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.id = &id
	mmDeleteUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.DeleteUser
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) Inspect(f func(ctx context.Context, id int64)) *mAuthRepositoryMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by AuthRepository.DeleteUser
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) Return(err error) *AuthRepositoryMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("AuthRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &AuthRepositoryMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &AuthRepositoryMockDeleteUserResults{err}
	mmDeleteUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// Set uses given function f to mock the AuthRepository.DeleteUser method
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) Set(f func(ctx context.Context, id int64) (err error)) *AuthRepositoryMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the AuthRepository.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the AuthRepository.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	mmDeleteUser.mock.funcDeleteUserOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// When sets expectation for the AuthRepository.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) When(ctx context.Context, id int64) *AuthRepositoryMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("AuthRepositoryMock.DeleteUser mock is already set by Set")
	}

	expectation := &AuthRepositoryMockDeleteUserExpectation{
		mock:               mmDeleteUser.mock,
		params:             &AuthRepositoryMockDeleteUserParams{ctx, id},
		expectationOrigins: AuthRepositoryMockDeleteUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.DeleteUser return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockDeleteUserExpectation) Then(err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times AuthRepository.DeleteUser should be invoked
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) Times(n uint64) *mAuthRepositoryMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of AuthRepositoryMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	mmDeleteUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUser
}

func (mmDeleteUser *mAuthRepositoryMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements mm_repository.AuthRepository
func (mmDeleteUser *AuthRepositoryMock) DeleteUser(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	mmDeleteUser.t.Helper()

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, id)
	}

	mm_params := AuthRepositoryMockDeleteUserParams{ctx, id}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockDeleteUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("AuthRepositoryMock.DeleteUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteUser.t.Errorf("AuthRepositoryMock.DeleteUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("AuthRepositoryMock.DeleteUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the AuthRepositoryMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, id)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to AuthRepositoryMock.DeleteUser. %v %v", ctx, id)
	return
}

// DeleteUserAfterCounter returns a count of finished AuthRepositoryMock.DeleteUser invocations
func (mmDeleteUser *AuthRepositoryMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of AuthRepositoryMock.DeleteUser invocations
func (mmDeleteUser *AuthRepositoryMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) Calls() []*AuthRepositoryMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.DeleteUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.DeleteUser at\n%s", m.DeleteUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.DeleteUser at\n%s with params: %#v", m.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.DeleteUser at\n%s", m.funcDeleteUserOrigin)
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.DeleteUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), m.DeleteUserMock.expectedInvocationsOrigin, afterDeleteUserCounter)
	}
}

type mAuthRepositoryMockReadUser struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockReadUserExpectation
	expectations       []*AuthRepositoryMockReadUserExpectation

	callArgs []*AuthRepositoryMockReadUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockReadUserExpectation specifies expectation struct of the AuthRepository.ReadUser
type AuthRepositoryMockReadUserExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockReadUserParams
	paramPtrs          *AuthRepositoryMockReadUserParamPtrs
	expectationOrigins AuthRepositoryMockReadUserExpectationOrigins
	results            *AuthRepositoryMockReadUserResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockReadUserParams contains parameters of the AuthRepository.ReadUser
type AuthRepositoryMockReadUserParams struct {
	ctx   context.Context
	email string
}

// AuthRepositoryMockReadUserParamPtrs contains pointers to parameters of the AuthRepository.ReadUser
type AuthRepositoryMockReadUserParamPtrs struct {
	ctx   *context.Context
	email *string
}

// AuthRepositoryMockReadUserResults contains results of the AuthRepository.ReadUser
type AuthRepositoryMockReadUserResults struct {
	up1 *model.UserInfo
	err error
}

// AuthRepositoryMockReadUserOrigins contains origins of expectations of the AuthRepository.ReadUser
type AuthRepositoryMockReadUserExpectationOrigins struct {
	origin      string
	originCtx   string
	originEmail string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadUser *mAuthRepositoryMockReadUser) Optional() *mAuthRepositoryMockReadUser {
	mmReadUser.optional = true
	return mmReadUser
}

// Expect sets up expected params for AuthRepository.ReadUser
func (mmReadUser *mAuthRepositoryMockReadUser) Expect(ctx context.Context, email string) *mAuthRepositoryMockReadUser {
	if mmReadUser.mock.funcReadUser != nil {
		mmReadUser.mock.t.Fatalf("AuthRepositoryMock.ReadUser mock is already set by Set")
	}

	if mmReadUser.defaultExpectation == nil {
		mmReadUser.defaultExpectation = &AuthRepositoryMockReadUserExpectation{}
	}

	if mmReadUser.defaultExpectation.paramPtrs != nil {
		mmReadUser.mock.t.Fatalf("AuthRepositoryMock.ReadUser mock is already set by ExpectParams functions")
	}

	mmReadUser.defaultExpectation.params = &AuthRepositoryMockReadUserParams{ctx, email}
	mmReadUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReadUser.expectations {
		if minimock.Equal(e.params, mmReadUser.defaultExpectation.params) {
			mmReadUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadUser.defaultExpectation.params)
		}
	}

	return mmReadUser
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.ReadUser
func (mmReadUser *mAuthRepositoryMockReadUser) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockReadUser {
	if mmReadUser.mock.funcReadUser != nil {
		mmReadUser.mock.t.Fatalf("AuthRepositoryMock.ReadUser mock is already set by Set")
	}

	if mmReadUser.defaultExpectation == nil {
		mmReadUser.defaultExpectation = &AuthRepositoryMockReadUserExpectation{}
	}

	if mmReadUser.defaultExpectation.params != nil {
		mmReadUser.mock.t.Fatalf("AuthRepositoryMock.ReadUser mock is already set by Expect")
	}

	if mmReadUser.defaultExpectation.paramPtrs == nil {
		mmReadUser.defaultExpectation.paramPtrs = &AuthRepositoryMockReadUserParamPtrs{}
	}
	mmReadUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmReadUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReadUser
}

// ExpectEmailParam2 sets up expected param email for AuthRepository.ReadUser
func (mmReadUser *mAuthRepositoryMockReadUser) ExpectEmailParam2(email string) *mAuthRepositoryMockReadUser {
	if mmReadUser.mock.funcReadUser != nil {
		mmReadUser.mock.t.Fatalf("AuthRepositoryMock.ReadUser mock is already set by Set")
	}

	if mmReadUser.defaultExpectation == nil {
		mmReadUser.defaultExpectation = &AuthRepositoryMockReadUserExpectation{}
	}

	if mmReadUser.defaultExpectation.params != nil {
		mmReadUser.mock.t.Fatalf("AuthRepositoryMock.ReadUser mock is already set by Expect")
	}

	if mmReadUser.defaultExpectation.paramPtrs == nil {
		mmReadUser.defaultExpectation.paramPtrs = &AuthRepositoryMockReadUserParamPtrs{}
	}
	mmReadUser.defaultExpectation.paramPtrs.email = &email
	mmReadUser.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

	return mmReadUser
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.ReadUser
func (mmReadUser *mAuthRepositoryMockReadUser) Inspect(f func(ctx context.Context, email string)) *mAuthRepositoryMockReadUser {
	if mmReadUser.mock.inspectFuncReadUser != nil {
		mmReadUser.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.ReadUser")
	}

	mmReadUser.mock.inspectFuncReadUser = f

	return mmReadUser
}

// Return sets up results that will be returned by AuthRepository.ReadUser
func (mmReadUser *mAuthRepositoryMockReadUser) Return(up1 *model.UserInfo, err error) *AuthRepositoryMock {
	if mmReadUser.mock.funcReadUser != nil {
		mmReadUser.mock.t.Fatalf("AuthRepositoryMock.ReadUser mock is already set by Set")
	}

	if mmReadUser.defaultExpectation == nil {
		mmReadUser.defaultExpectation = &AuthRepositoryMockReadUserExpectation{mock: mmReadUser.mock}
	}
	mmReadUser.defaultExpectation.results = &AuthRepositoryMockReadUserResults{up1, err}
	mmReadUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadUser.mock
}

// Set uses given function f to mock the AuthRepository.ReadUser method
func (mmReadUser *mAuthRepositoryMockReadUser) Set(f func(ctx context.Context, email string) (up1 *model.UserInfo, err error)) *AuthRepositoryMock {
	if mmReadUser.defaultExpectation != nil {
		mmReadUser.mock.t.Fatalf("Default expectation is already set for the AuthRepository.ReadUser method")
	}

	if len(mmReadUser.expectations) > 0 {
		mmReadUser.mock.t.Fatalf("Some expectations are already set for the AuthRepository.ReadUser method")
	}

	mmReadUser.mock.funcReadUser = f
	mmReadUser.mock.funcReadUserOrigin = minimock.CallerInfo(1)
	return mmReadUser.mock
}

// When sets expectation for the AuthRepository.ReadUser which will trigger the result defined by the following
// Then helper
func (mmReadUser *mAuthRepositoryMockReadUser) When(ctx context.Context, email string) *AuthRepositoryMockReadUserExpectation {
	if mmReadUser.mock.funcReadUser != nil {
		mmReadUser.mock.t.Fatalf("AuthRepositoryMock.ReadUser mock is already set by Set")
	}

	expectation := &AuthRepositoryMockReadUserExpectation{
		mock:               mmReadUser.mock,
		params:             &AuthRepositoryMockReadUserParams{ctx, email},
		expectationOrigins: AuthRepositoryMockReadUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReadUser.expectations = append(mmReadUser.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.ReadUser return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockReadUserExpectation) Then(up1 *model.UserInfo, err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockReadUserResults{up1, err}
	return e.mock
}

// Times sets number of times AuthRepository.ReadUser should be invoked
func (mmReadUser *mAuthRepositoryMockReadUser) Times(n uint64) *mAuthRepositoryMockReadUser {
	if n == 0 {
		mmReadUser.mock.t.Fatalf("Times of AuthRepositoryMock.ReadUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadUser.expectedInvocations, n)
	mmReadUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadUser
}

func (mmReadUser *mAuthRepositoryMockReadUser) invocationsDone() bool {
	if len(mmReadUser.expectations) == 0 && mmReadUser.defaultExpectation == nil && mmReadUser.mock.funcReadUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadUser.mock.afterReadUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReadUser implements mm_repository.AuthRepository
func (mmReadUser *AuthRepositoryMock) ReadUser(ctx context.Context, email string) (up1 *model.UserInfo, err error) {
	mm_atomic.AddUint64(&mmReadUser.beforeReadUserCounter, 1)
	defer mm_atomic.AddUint64(&mmReadUser.afterReadUserCounter, 1)

	mmReadUser.t.Helper()

	if mmReadUser.inspectFuncReadUser != nil {
		mmReadUser.inspectFuncReadUser(ctx, email)
	}

	mm_params := AuthRepositoryMockReadUserParams{ctx, email}

	// Record call args
	mmReadUser.ReadUserMock.mutex.Lock()
	mmReadUser.ReadUserMock.callArgs = append(mmReadUser.ReadUserMock.callArgs, &mm_params)
	mmReadUser.ReadUserMock.mutex.Unlock()

	for _, e := range mmReadUser.ReadUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmReadUser.ReadUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadUser.ReadUserMock.defaultExpectation.Counter, 1)
		mm_want := mmReadUser.ReadUserMock.defaultExpectation.params
		mm_want_ptrs := mmReadUser.ReadUserMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockReadUserParams{ctx, email}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReadUser.t.Errorf("AuthRepositoryMock.ReadUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadUser.ReadUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmReadUser.t.Errorf("AuthRepositoryMock.ReadUser got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadUser.ReadUserMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadUser.t.Errorf("AuthRepositoryMock.ReadUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReadUser.ReadUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadUser.ReadUserMock.defaultExpectation.results
		if mm_results == nil {
			mmReadUser.t.Fatal("No results are set for the AuthRepositoryMock.ReadUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmReadUser.funcReadUser != nil {
		return mmReadUser.funcReadUser(ctx, email)
	}
	mmReadUser.t.Fatalf("Unexpected call to AuthRepositoryMock.ReadUser. %v %v", ctx, email)
	return
}

// ReadUserAfterCounter returns a count of finished AuthRepositoryMock.ReadUser invocations
func (mmReadUser *AuthRepositoryMock) ReadUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadUser.afterReadUserCounter)
}

// ReadUserBeforeCounter returns a count of AuthRepositoryMock.ReadUser invocations
func (mmReadUser *AuthRepositoryMock) ReadUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadUser.beforeReadUserCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.ReadUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadUser *mAuthRepositoryMockReadUser) Calls() []*AuthRepositoryMockReadUserParams {
	mmReadUser.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockReadUserParams, len(mmReadUser.callArgs))
	copy(argCopy, mmReadUser.callArgs)

	mmReadUser.mutex.RUnlock()

	return argCopy
}

// MinimockReadUserDone returns true if the count of the ReadUser invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockReadUserDone() bool {
	if m.ReadUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadUserMock.invocationsDone()
}

// MinimockReadUserInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockReadUserInspect() {
	for _, e := range m.ReadUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.ReadUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadUserCounter := mm_atomic.LoadUint64(&m.afterReadUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadUserMock.defaultExpectation != nil && afterReadUserCounter < 1 {
		if m.ReadUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.ReadUser at\n%s", m.ReadUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.ReadUser at\n%s with params: %#v", m.ReadUserMock.defaultExpectation.expectationOrigins.origin, *m.ReadUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadUser != nil && afterReadUserCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.ReadUser at\n%s", m.funcReadUserOrigin)
	}

	if !m.ReadUserMock.invocationsDone() && afterReadUserCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.ReadUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadUserMock.expectedInvocations), m.ReadUserMock.expectedInvocationsOrigin, afterReadUserCounter)
	}
}

type mAuthRepositoryMockUpdateUser struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockUpdateUserExpectation
	expectations       []*AuthRepositoryMockUpdateUserExpectation

	callArgs []*AuthRepositoryMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockUpdateUserExpectation specifies expectation struct of the AuthRepository.UpdateUser
type AuthRepositoryMockUpdateUserExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockUpdateUserParams
	paramPtrs          *AuthRepositoryMockUpdateUserParamPtrs
	expectationOrigins AuthRepositoryMockUpdateUserExpectationOrigins
	results            *AuthRepositoryMockUpdateUserResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockUpdateUserParams contains parameters of the AuthRepository.UpdateUser
type AuthRepositoryMockUpdateUserParams struct {
	ctx  context.Context
	user *model.UpdateUser
}

// AuthRepositoryMockUpdateUserParamPtrs contains pointers to parameters of the AuthRepository.UpdateUser
type AuthRepositoryMockUpdateUserParamPtrs struct {
	ctx  *context.Context
	user **model.UpdateUser
}

// AuthRepositoryMockUpdateUserResults contains results of the AuthRepository.UpdateUser
type AuthRepositoryMockUpdateUserResults struct {
	err error
}

// AuthRepositoryMockUpdateUserOrigins contains origins of expectations of the AuthRepository.UpdateUser
type AuthRepositoryMockUpdateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) Optional() *mAuthRepositoryMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for AuthRepository.UpdateUser
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) Expect(ctx context.Context, user *model.UpdateUser) *mAuthRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("AuthRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &AuthRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("AuthRepositoryMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &AuthRepositoryMockUpdateUserParams{ctx, user}
	mmUpdateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.UpdateUser
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("AuthRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &AuthRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("AuthRepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &AuthRepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectUserParam2 sets up expected param user for AuthRepository.UpdateUser
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) ExpectUserParam2(user *model.UpdateUser) *mAuthRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("AuthRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &AuthRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("AuthRepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &AuthRepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.user = &user
	mmUpdateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.UpdateUser
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) Inspect(f func(ctx context.Context, user *model.UpdateUser)) *mAuthRepositoryMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by AuthRepository.UpdateUser
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) Return(err error) *AuthRepositoryMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("AuthRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &AuthRepositoryMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &AuthRepositoryMockUpdateUserResults{err}
	mmUpdateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// Set uses given function f to mock the AuthRepository.UpdateUser method
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) Set(f func(ctx context.Context, user *model.UpdateUser) (err error)) *AuthRepositoryMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the AuthRepository.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the AuthRepository.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	mmUpdateUser.mock.funcUpdateUserOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// When sets expectation for the AuthRepository.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) When(ctx context.Context, user *model.UpdateUser) *AuthRepositoryMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("AuthRepositoryMock.UpdateUser mock is already set by Set")
	}

	expectation := &AuthRepositoryMockUpdateUserExpectation{
		mock:               mmUpdateUser.mock,
		params:             &AuthRepositoryMockUpdateUserParams{ctx, user},
		expectationOrigins: AuthRepositoryMockUpdateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.UpdateUser return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockUpdateUserExpectation) Then(err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockUpdateUserResults{err}
	return e.mock
}

// Times sets number of times AuthRepository.UpdateUser should be invoked
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) Times(n uint64) *mAuthRepositoryMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of AuthRepositoryMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	mmUpdateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUser
}

func (mmUpdateUser *mAuthRepositoryMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements mm_repository.AuthRepository
func (mmUpdateUser *AuthRepositoryMock) UpdateUser(ctx context.Context, user *model.UpdateUser) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	mmUpdateUser.t.Helper()

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, user)
	}

	mm_params := AuthRepositoryMockUpdateUserParams{ctx, user}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockUpdateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUser.t.Errorf("AuthRepositoryMock.UpdateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmUpdateUser.t.Errorf("AuthRepositoryMock.UpdateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("AuthRepositoryMock.UpdateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the AuthRepositoryMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, user)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to AuthRepositoryMock.UpdateUser. %v %v", ctx, user)
	return
}

// UpdateUserAfterCounter returns a count of finished AuthRepositoryMock.UpdateUser invocations
func (mmUpdateUser *AuthRepositoryMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of AuthRepositoryMock.UpdateUser invocations
func (mmUpdateUser *AuthRepositoryMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) Calls() []*AuthRepositoryMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.UpdateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.UpdateUser at\n%s", m.UpdateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.UpdateUser at\n%s with params: %#v", m.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.UpdateUser at\n%s", m.funcUpdateUserOrigin)
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.UpdateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), m.UpdateUserMock.expectedInvocationsOrigin, afterUpdateUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateLogInspect()

			m.MinimockCreateUserInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockReadUserInspect()

			m.MinimockUpdateUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateLogDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockReadUserDone() &&
		m.MinimockUpdateUserDone()
}
